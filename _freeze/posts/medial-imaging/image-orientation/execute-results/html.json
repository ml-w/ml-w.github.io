{
  "hash": "0aea29660e33f37ac80f160762a94223",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Stochastic - Particle Filtering and Markov Chain Monte Carlo\"\nauthor: \"MLun Wong\"\ndate: \"2017-03-10\"\ncategories: [DICOM, NIFTI, image orientation, vtk, itk]\n# jupyter: conda-env-vtk-py\n---\n\n::: serif-content\n# Background\n\nDirections and orientation of medical images are indeed a very confusing problem, especially when you are trying to handle multiple images (then relative spacing becomes a concern). There are also **multiple conventions** to view these image (e.g. neurologist view and radiologist view, which defines the righthandness of the image), adding further confusions to the problem.\n\nFor most volume storage format,  a list of the most important components which defines a meaning image would be:\n\n1.  Voxel data\n\n2.  Image Origin\n\n3.  Image Spacing\n\n4.  Direction\n\nThese data are usually stored separately to maximize storage efficiency. Voxel data is always along Euclidean xyz-axises, which might not accurately represents the actual physical location each pixel. For instance, imagine you gave a metal bar two CT scans, one with it aligned perfectly with the machine's rotational axis, the second with it purposely tilted 60° from the axis. The most effective way to store these two image is obviously by drawing the grid with the z-axis along the bar so that the **voxel data** stored is actually identically. However, we need to account for the 60° tilt of the second bar, which is achieved by specifying **direction** of the image. Similar though experiment goes with **image origin**, you get the idea?\n\nThis post tries to give a simplified explanation and solution to this problem for ITK and VTK users.\n\n# Image Formats\n\nWe consider only two of the most commonly seen medical image format, namely **NIfTI** and **DICOM** images. These two image formats use different hierarchy to store the direction information. While NIfTI images use QForm matrix and SForm matrix to store direction information, DICOM images use the DICOM tag stating cosines of angles. This topic will be discussed in detail in later sections.\n\n## Image loading methods\n\nThree loading methods are considered in this post:\n\n1.  Load as ITK image.\n\n2.  Load as ITK image then use convert to vtkImageData.\n\n3.  Load as vtkImageData.\n\nTabulating their characters w.r.t. image directions:\n\n|                  | Has Direction | Has Origin | Has Orientation |\n|------------------|---------------|------------|-----------------|\n| ITK Image Loader | Yes           | Yes        | Yes             |\n| ITK to VTK       | No            | Yes        | No              |\n| VTK Image Loader | No            | No         | No              |\n\n## Defining Terms\n\n### Image Origin\n\n> Image origin is the position of the corner of the first stored voxel (i.e. index *ijk* = \\[0,0,0\\]). Which of the 8 corners depends on whether the image is righthanded or lefthanded, this give rise to the orientation definition.\n\n### Image Orientation\n\n> Image orientation refers to the specification of the three principle axis w.r.t. voxel index. First, we introduce a notion, +*x* means the x-coordinate increase with the first index *i* of the voxel., similar for +*y* and +*z*. A more common notion would be the permutation of six direction LR, SP and AP, e.g. RAI/LPS...etc. This, however, doesn't defines the image  xyz-axis yet since they can be along any directions. Therefore, we requires the definition of **Image Direction**.\n\n# Data Storage Format\n\n## DICOM Images\n\n### Image Origin\n\n> Image origin of DICOM image is stored in the DICOM tag \"**Image Position (Patient) (0020,0032)**\", which is a simple offset against all the voxel coordinates. Note that each slices has it's own value of Image Position, but we only concern the first slice.\n\n###  Image Direction\n\n> Image direction of DICOM image is stored in DICOM tag \"**Image Orientation (Patient) (0020,0037)**\", it is defined as the cosines of angle of three axis. Every slice of the same series (except for scouts) should have the same orientation.\n\n## NIFTI\n\n### Image Origin\n\n> The image origin of Nifti files are stored in the quantity **qoffsets** and the fourth element of **srow_x/y/z** in the header. Usually, they are the same so you can just use one of them.\n\n### Image Direction\n\n> Image directions of Nifti files are defined by two matrices in the header, namely **SForm Matrix** and **QForm Matrix**, which, in most cases, are the essentially the same matrix except SForm Matrix includes the spacing . The usage of these two matrices are defined by two quantity called **sform code** and **qform code**, and the QForm Matrix is defined by a vector **quaternion**. According to the [documentation](https://nifti.nimh.nih.gov/nifti-1/documentation/nifti1fields/nifti1fields_pages/qsform.html), three methods are mentioned for using these matrices depending on whether the qform code and sform code are 0 or not.\n\n# Data Loading Strategy\n\n## DICOM\n\nGenerally DICOM can be seen as a series of 2D images with extra information stored in headers. However, an image can be sliced along different normals, for example sagital, coronal or axial. These three direction are not the only direction that a DICOM series can take on, in fact, a DICOM series can be sliced along any directions. The slice direction is decided by the  \"**Image Orientation (Patient) (0020,0037)**\" DICOM tag, which specify the reference frame. The \"**Image Orientation(Patient)\"** is a 6-element tuple consist of two vectors which *describes the axis of the direction for row and column of that particular slice.* For example, if your slices are Axial slice, then the two vectors defines sagital and coronal directions.\n\nIf the tag is **\"a**\\b\\c\\d\\e\\f\\g\", then the cross product of the two vectors gives the third colume of the rotational matrix, i.e:\n\nIf the corresponding axis vectors will be\n\n$$\n\\begin{align} \n\\vec{v}_x &= \\begin{bmatrix} a&b&c \\end{bmatrix}^T \\\\ \n\\vec{v}_y &= \\begin{bmatrix} d&e&f \\end{bmatrix}^T \\\\ \n\\vec{v}_z &= \\vec{v}_x \\times \\vec{v}_y \\end{align}\n$$\n\n## NIFTI\n\nTo properly load the image data, we first examine the qform and sform code, that perform action according the the conditions below.\n\n**If qform = 0**\n\nThis method is for backwards compatibility only. When qform code = 0, the matrices will not be used to define the orientation and direction, the index to coordinate matrix is simply the following:\n\n$$\n\\vec{r} = \\vec{s}^{\\text{ }T} \\cdot \\vec{I}\\\n$$\n\nwhere **r** is physical coordinate, **s** is spacing vector and **I** is the index vector (i.e. \\$ \\vec{I} = \\[i, j, k\\] \\$). In this case, no further transformation is need after image loading (or the transform is Identity matrix).\n\n#### **If qform \\> 0**\n\nWhen qform code is greater than zero, this method applies. This method involves constructing a rotation matrix using a so called **quaternion representation**.\n\nDefinition of quaternion:\n\n$$ \\vec{q} =\\begin{bmatrix} a\\\\b\\\\c\\\\d \\end{bmatrix} $$\n\nwhere we require that:\n\n$$  a^2 + b^2 + c^2 + d^2 = 1$$\n\nSo having three of the four values gives the remaining one. In nifti format, only b, c, d are given in the header, and we calculate a by the formula:\n\n\\$ \\displaystyle a = \\sqrt{1 - b^2 - c^2 - d^2} \\$\n\nUsing a, b, c, d the rotational matrix **R** is defined as:\n\n$$ \\displaystyle\n\\text{R}_q = \\begin{bmatrix}\na^2 + b^2 - c^2 - d^2&2bc - 2ad&2bd+2ac\\\\\n2bc + 2ad& a^2 + c^2 - b^2 - d^2& 2cd - 2ab\\\\\n2bd - 2ac&2cd + 2ab&a^2 + d^2 - c^2 - b^2\\\\\n\\end{bmatrix}\n$$\n\nThe index to physical position formula would therefore be:\n\n$$ \\displaystyle\n\\vec{r} = \\text{R}_q [\\vec{s}^{\\text{ }T}\\cdot \\vec{I}\\] + \\vec{q}_0\\\n$$\n\nwhere **q_0** stands for qoffsets.\n\nHence the affine matrix `vtkMatrix4x4` used for transform in VTK would be\n\n$$ \\displaystyle\n\\text{A} = \\begin{bmatrix}\\\na^2 + b^2 - c^2 - d^2&2bc - 2ad&2bd+2ac&q_x\\\\\n2bc + 2ad& a^2 + c^2 - b^2 - d^2& 2cd - 2ab&q_y\\\\\n2bd - 2ac&2cd + 2ab&a^2 + d^2 - c^2 - b^2&q_z\\\\\n0&0&0&1\\\n\\end{bmatrix}\\\n$$\n\n#### **If sform \\> 0**\n\nThis can coexist with qform \\> 0 (i.e. both qform \\> 0 and sform \\> 0 can coexist, qform describe the transformation from data to scanning grid, sform describe the transformation from data to standard grid). The sform matrix is stored separately in three vectors: **SRowX, SRowY** and **SRowZ**, which we will denote as: \\$ \\vec{g}\\_x, \\vec{g}\\_y, \\vec{g}\\_z \\$.\n\n$$\n\\displaystyle \\text{R}_s =\\begin{bmatrix}g_{x_1}&g_{x_2}&g_{x_3}\\\\g_{y_1}&g_{y_2}&g_{y_3}\\\\g_{z_1}&g_{z_2}&g_{z_3} \\end{bmatrix}\n$$\n\nSince the SForm matrix already include spacing, there are no needs to multiply spacing for each index. The index to physical position formula would therefore be:\n\n$$\n\\displaystyle\n\\vec{r} = \\text{R}_s \\vec{I} + \\begin{bmatrix} g_{x_4}\\\\g_{y_4}\\\\g_{z_4} \\end{bmatrix}\\\n$$\n\nThe affine matrix used for transform in `vtkMatrix4x4` would then be the rotational matrix divided by spacing spacing vector **s**:\n\n$$\n\\displaystyle\\\n\\text{A} =\\\n\\begin{bmatrix}\\\n\\frac{g_{x_1}}{s_1}&\\frac{g_{x_2}}{s_2}&\\frac{g_{x_3}}{s_3}&g_{x_4}\\\\\n\\frac{g_{y_1}}{s_1}&\\frac{g_{y_2}}{s_2}&\\frac{g_{y_3}}{s_3}&g_{y_4}\\\\\n\\frac{g_{z_1}}{s_1}&\\frac{g_{z_2}}{s_2}&\\frac{g_{z_3}}{s_3}&g_{z_4}\\\\\n0&0&0&1\\\n\\end{bmatrix}\\\n$$\n\n### Code Example (VTK & Python)\n\n::: {#812276b6 .cell execution_count=1}\n``` {.python .cell-code}\nimport vtk\nimport numpy as np\nimport tempfile\nimport SimpleITK as sitk\nfrom pprint import pprint\n\n# Create a fake image with simpleitk\nimage = sitk.Image(28, 28, 28, sitk.sitkUInt8)\nimage.SetSpacing([0.5, 0.1, 0.2])\n\n# Set directio to:\n#  [1, 0, 0]\n#  [0, 0, 1]\n#  [0, 1, 0]\nimage.SetDirection((1., 0., 0., 0., 0., 1., 0., 1., 0.))\n\n# Write this dummy image for VTK to read\nwith tempfile.TemporaryDirectory() as f:\n    sitk.WriteImage(image, f + \"/temp.nii.gz\")\n\n    # read it back with vtk\n    reader = vtk.vtkNIFTIImageReader()\n    reader.SetFileName(f + \"/temp.nii.gz\")\n    reader.Update()\n \n    header = reader.GetNIFTIHeader()\n    vtkimage = reader.GetOutput()\n\nprint(\"ITK: \")\npprint(np.asarray(image.GetDirection()).reshape(3, 3))\nprint(\"VTK: \")\nprint(vtkimage.GetDirectionMatrix())\n```\n:::\n\n\n## Output\n\n::: cell-output-display\n``` md\nITK: \narray([[1., 0., 0.],\n       [0., 0., 1.],\n       [0., 1., 0.]])\nVTK: \nvtkMatrix3x3 (0000025FBE641A50)\n  Debug: Off\n  Modified Time: 1319\n  Reference Count: 2\n  Registered Events: (none)\n  Elements:\n    1   0   0\n    0   1   0\n    0   0   1\n```\n:::\n\nSee how the two matrix are different? In fact VTK did not load the the direction into the matrix and therefore it remained as the default identity matrix.\n\n# Fix\n\n::: {#837f28fa .cell execution_count=2}\n``` {.python .cell-code}\n#Spacing\ns = image.GetSpacing()\ns = np.array([s[0], s[1], s[2], 1])\n \n#Origin (Set this to [0, 0, 0, 1] if you are using itkvtkConnector)\nori = np.array( [header.GetQOffsetX(), header.GetQOffsetY(), header.GetQOffsetZ(), 1])\n \n'''Directions'''\n# Use QForm matrix\nif (header.GetQFormCode() > 0):\n    b = header.GetQuaternB()\n    c = header.GetQuaternC()\n    d = header.GetQuaternD()\n    a = np.sqrt(1 - b*b - c*c - d*d)\n    A = np.array([\n        [a*a + b*b - c*c - d*d, 2*b*c - 2*a*d, 2*b*d + 2*a*c, ori[0]],\n        [2*b*c + 2*a*d, a*a+c*c-b*b-d*d, 2*c*d - 2*a*b, ori[1]],\n        [2*b*d - 2*a*c, 2*c*d + 2*a*b, a*a + d*d - c*c - b*b, ori[2]],\n        [0, 0, 0, 1]\n    ])\n\n    # Obtain user transform for vtk algorithms\n    mat = vtk.vtkMatrix4x4()\n    [[mat.SetElement(i, j, A[i, j]) for i in range(4)] for j in range(4)]\n    print(\"From qform: \\n\", mat)\n \n# Use SForm Matrix\nif (header.GetSFormCode() > 0):\n    gx = header.GetSRowX()\n    gy = header.GetSRowY()\n    gz = header.GetSRowZ()\n\n    # divide SForm matrix by spacing\n    gx /= s\n    gy /= s\n    gz /= s\n    A = np.zeros([4,4])\n    A[3, 3] = 1\n    A[0,:] = gx\n    A[1,:] = gy\n    A[2,:] = gz\n    # Obtain user transform for vtk algorithms\n    mat = vtk.vtkMatrix4x4()\n    [[mat.SetElement(i, j, A[i, j]) for i in range(4)] for j in range(4)]\n    print(\"From SForm: \\n\", mat)\n```\n:::\n\n\n## Output\n\n::: cell-output-display\n``` md\nFrom qform: \n vtkMatrix4x4 (0000025FBEC509E0)\n  Debug: Off\n  Modified Time: 1478\n  Reference Count: 1\n  Registered Events: (none)\n  Elements:\n    -1 -0.000261643 0.000261643 0 \n    0.000261643 3.42285e-08 1 0 \n    -0.000261643 1 3.42285e-08 0 \n    0 0 0 1 \n\n\nFrom SForm: \n vtkMatrix4x4 (0000025FBEC4FF40)\n  Debug: Off\n  Modified Time: 1484\n  Reference Count: 1\n  Registered Events: (none)\n  Elements:\n    -1 0 0 0 \n    0 -0 -1 0 \n    0 1 0 0 \n    0 0 0 1 \n```\n:::\n\nNow if you round them up, you can see how this is corrected, but the x-axis and y-axis are now inverted. THis is because vtk and itk has inherently different orientation. While ITK defaults image to RAI orientation (Medical image convention), VTK defaults image to LPI (Computer graphics convention). Specifically, if you look at MRI images, the structures one the right actually belongs to the left side of the patient, as if the patient is standing facing the viewer. Knowing these subtle different would help to figure why the orientation is always messed up if you use `VTK` and `ITK` interchangibly.\n\n![Fig. 1 ITK-snap display of the CT of a patient. Data collected and releasted to the public domain by Aerts et al \\[1\\].](images/paste-1.png){fig-align=\"center\"}\n\n# Reference\n\n1.  Aerts, H. J., Velazquez, E. R., Leijenaar, R. T., Parmar, C., Grossmann, P., Carvalho, S., Bussink, J., Monshouwer, R., Haibe-Kains, B., Rietveld, D., Hoebers, F., Rietbergen, M. M., Leemans, C. R., Dekker, A., Quackenbush, J., Gillies, R. J., & Lambin, P. (2014). Decoding tumour phenotype by noninvasive imaging using a quantitative radiomics approach \\[Article\\]. Nat Commun, 5, 4006, Article 4006. <https://doi.org/10.1038/ncomms5006>\n:::\n\n",
    "supporting": [
      "image-orientation_files"
    ],
    "filters": [],
    "includes": {}
  }
}